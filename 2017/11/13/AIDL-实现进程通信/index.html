<!DOCTYPE HTML>
<html>
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->



<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>AIDL 实现进程通信 | Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css?rev=3.3.4">
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
    <div class="hide">
    	<script src="https://s4.cnzz.com/z_stat.php?id=1263868967&web_id=1263868967" language="JavaScript"></script>
    </div>






    
</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner2.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="">
            <img src="/img/avatar.jpg" alt="logo头像">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题">  
             
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only">Toggle navigation</span>
                    <i class="fa fa-bars"></i>
                    </span>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation"><a href="/"><i class="fa fa-fw "></i>首页</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/Android/"><i class="fa fa-fw "></i>Android</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/后端/"><i class="fa fa-fw "></i>后端</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/工具/"><i class="fa fa-fw "></i>工具</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/随笔/"><i class="fa fa-fw "></i>随笔</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="AIDL 实现进程通信">
            
            AIDL 实现进程通信
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <span>Android</span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            Android 进程间通信
            
        </span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">2017/11/13</span>
    </span>
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>首先我们先从客户端和服务端来了解AIDL的跨进程通信的过程。</p>
<h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><p>服务器首先要创建一个 Service 用来监听客户端的连接请求，然后创建一个 AIDL 文件，将暴露给客户端的这个接口在这个 AIDL 文件中声明，最后在 Service 中实现这个 AIDL 的接口即可。</p>
<h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><p>客户端要做的就是绑定服务端的 Service，绑定成功后，将服务端的返回的 Binder对象转换为 AIDl 接口所属的类型，接着就可以调用 AIDL 中的方法了。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>下面来看看其实现的具体过程</p>
<h3 id="1、创建-AIDL-接口"><a href="#1、创建-AIDL-接口" class="headerlink" title="1、创建 AIDL 接口"></a>1、创建 AIDL 接口</h3><p>  跟之前学习 Binder 时一样，创建了一个 .aidl 文件，里面声明了一个接口和两个接口方法。</p>
<pre><code>// IBookManager.aidl
package com.ydsd.binderdemo;

import com.ydsd.binderdemo.Book;

interface IBookManager {
    List&lt;Book&gt; getBookList();
    void addBook(in Book book);
}
</code></pre><p>这里需要注意的是，在AIDL中，只支持以下几种类型：</p>
<ul>
<li>基本数据类型（int、long、char、boolean、double等）；</li>
<li>String和CharSequence ;</li>
<li>List : 只支持ArrayList，里面每个元素都必须被 AIDL 支持。</li>
<li>Map ： 只支持HaseMap ， 里面每个元素都必须被 AIDL 支持，包括 key 和 value。</li>
<li>Parcelable ： 所有实现了 Parcelable 的对象。</li>
<li>AIDL ：所有 AIDL 接口本身也可以在 AIDL 文件中使用。</li>
</ul>
<p>在这6中类型中，其中自定义的 Parceable 对象和 AIDL 对象必须要显示的用 import 引进来，不管它们是否在一个包下。例如这个接口中用到了 Book 这个类，这个类是自定的 Parcelable 对象，所以必须新建一个 Book.aidl 文件并在里面声明 parcelable book 如下所示：</p>
<pre><code>// Book.aidl
package com.ydsd.binderdemo;

parcelable Book;
</code></pre><p>除此之外，AIDL 中除了基本类型，其他类型的参数必须标上方向：in、out、inout，in 表示输入型参数，out 表示输出型参数。另外 AIDL 中只支持方法，不支持声明静态常量。为了方便 AIDL 开发，建议把所有和 AIDL 相关的类和文件全部放在同一个包中。</p>
<h3 id="2、远程服务端Service的实现"><a href="#2、远程服务端Service的实现" class="headerlink" title="2、远程服务端Service的实现"></a>2、远程服务端Service的实现</h3><p>上面讲述了如何定义 AIDL 接口，接下来我们就来实现这个接口，我们先创建一个 Service，称为 BookManagerService，代码如下：</p>
<pre><code>public class BookManagerService extends Service{

    private static final String TAG = &quot;BMS&quot;;

    private CopyOnWriteArrayList&lt;Book&gt; mBookList =new CopyOnWriteArrayList&lt;&gt;();

    private Binder mBinder =new IBookManager.Stub() {
        @Override
        public List&lt;Book&gt; getBookList() throws RemoteException {
            return mBookList;
        }

        @Override
        public void addBook(Book book) throws RemoteException {
            mBookList.add(book);
        }
    };

    @Override
    public void onCreate() {
        super.onCreate();
        mBookList.add(new Book(1,&quot;Android 开发艺术探索&quot;));
        mBookList.add(new Book(2,&quot;第一行代码&quot;));
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }
}
</code></pre><p>上面是一个服务端的典型实现，在 onCreate() 中，我们首先添加了两本书，然后创建了一个 Binder 对象并在 onBinder() 中返回它，这个对象继承 IBookManager.Stub 并实现了它内部的 AIDL 方法。</p>
<p>需要注意的是，由于 AIDL 方法是在服务端的 Binder 线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程并发访问的现象，所以要在 AIDL 中处理线程同步，所以这里使用 CopyOnWriteArrayList 来进行线程的自动同步。</p>
<p>然后需要给这个 Service 指定固定的进程：</p>
<pre><code>&lt;service
            android:name=&quot;.aidl.BookManagerService&quot;
            android:process=&quot;:remote&quot;/&gt;
</code></pre><h3 id="3、客户端的实现"><a href="#3、客户端的实现" class="headerlink" title="3、客户端的实现"></a>3、客户端的实现</h3><p>客户端首先要绑定 Service ，绑定成功后将获取服务端返回的 Binder 转换成 AIDL 接口，然后根据这个接口去调用服务端远程的方法。代码如下：</p>
<pre><code>public class BookManagerActivity extends AppCompatActivity {
    private static final String TAG = &quot;BookManagerActivity&quot;;

    private ServiceConnection mServiceConnection=new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
            IBookManager bookManager = IBookManager.Stub.asInterface(iBinder);
            try {
                List&lt;Book&gt; bookList = bookManager.getBookList();
                Log.i(TAG,&quot;查询图书列表：&quot;+bookList.toString());
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName componentName) {

        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_book_manager);
        Intent intent =new Intent(this,BookManagerService.class);
        bindService(intent,mServiceConnection,BIND_AUTO_CREATE);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unbindService(mServiceConnection);
    }
}
</code></pre><p>到这里，我们就完成了使用 AIDL 进行 IPC。接着我们在调用一下另一个接口 addBook（）往服务器添加一本图书试试。</p>
<p><img src="/2017/11/13/AIDL-实现进程通信/1.png" alt="图片加载失败"></p>
<p>运行程序，发现addBook（）成功的被调用了。</p>
<h3 id="4、实现观察者模式"><a href="#4、实现观察者模式" class="headerlink" title="4、实现观察者模式"></a>4、实现观察者模式</h3><p>到这里，我们已经实现了 AIDL 的基本功能，但 AIDL 远没有看上去的这么简单。</p>
<p>接下来，我们来讨论并实现一种新的场景：即用户（客户端）不用时不时的去查询图书列表，当图书列表有新书添加的时候会自动的通知对这本图书感兴趣的人。这就是一种典型的观察者模式。</p>
<p>每个感兴趣的用户都观察新书，当有新书到时，图书馆就通知每个对这本书感兴趣的用户。</p>
<p>首先，我们先创建一个监听新书的接口，由于 AIDL 中不支持普通接口，所以我们需要创建一个 AIDL 接口。 代码如下:</p>
<pre><code>// IOnNewBookArrivedListener.aidl
package com.ydsd.binderdemo.aidl;

import com.ydsd.binderdemo.aidl.Book;


interface IOnNewBookArrivedListener {
    void onNewBookArrived(in Book book);
}
</code></pre><p>然后给 IBookManager.aidl 接口，增加注册和取消监听的方法。</p>
<p><img src="/2017/11/13/AIDL-实现进程通信/2.png" alt="图片加载失败"></p>
<p>接下来，去服务端实现我们在 IBookManager.aidl 中新增的这两个方法。然后再在一个线程中每五秒添加一本新书，并通知每个对它感兴趣的人。</p>
<pre><code>public class BookManagerService extends Service{

    private static final String TAG = &quot;BMS&quot;;
    private AtomicBoolean mIsServiceDestory = new AtomicBoolean(false);
    private CopyOnWriteArrayList&lt;Book&gt; mBookList =new CopyOnWriteArrayList&lt;&gt;();
    private CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt;  mListenerList=new CopyOnWriteArrayList&lt;&gt;();

    private Binder mBinder =new IBookManager.Stub() {
        @Override
        public List&lt;Book&gt; getBookList() throws RemoteException {
            return mBookList;
        }
        @Override
        public void addBook(Book book) throws RemoteException {
            mBookList.add(book);
        }

        @Override
        public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException {
            if (!mListenerList.contains(listener)){
                mListenerList.add(listener);
            }else {
                Log.d(TAG,&quot;已经存在&quot;);
            }
            Log.d(TAG,&quot;注册的listener数：&quot;+mListenerList.size());
        }

        @Override
        public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException {
            if (mListenerList.contains(listener)){
                mListenerList.remove(listener);
            }else{
                Log.d(TAG,&quot;没有找到&quot;);
            }
            Log.d(TAG,&quot;解绑成功，当前绑定用户：&quot;+mListenerList.size());
        }
    };

    @Override
    public void onCreate() {
        super.onCreate();
        mBookList.add(new Book(1,&quot;Android 开发艺术探索&quot;));
        mBookList.add(new Book(2,&quot;第一行代码&quot;));
        new Thread(new ServiceWorker()).start();
    }

    @Override
    public void onDestroy() {
        mIsServiceDestory.set(true);
        super.onDestroy();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }


    private class ServiceWorker implements Runnable{
        @Override
        public void run() {
            //在后台执行。。。。
            while(!mIsServiceDestory.get()){
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int bookId=mBookList.size()+1;
                Book newBook =new Book(bookId,&quot;新书&quot;+bookId);
                try {
                    onNewBookArrived(newBook);
                    Log.d(TAG,&quot;添加了一本新书&quot;);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private void onNewBookArrived(Book newBook) throws RemoteException {
        mBookList.add(newBook);
        Log.d(TAG,&quot;新书到了，通知了&quot;+mListenerList.size()+&quot;位用户&quot;);
        for (int i=0;i&lt;mListenerList.size();i++){
            IOnNewBookArrivedListener listener=mListenerList.get(i);
            Log.d(TAG,&quot;通知了用户：&quot;+listener);
            listener.onNewBookArrived(newBook);
        }
    }
}
</code></pre><p>最后，我们还需要修改客户端代码，首先客户端要注册 IOnNewBookArrivedListener 到远程服务，这样当有新书时才能通知到客户端。 同时，要在 activity 退出时 解除这个注册。 另一方面，当有新书到时， onNewBookArrived 方法是运行在客户端的 Binder 线程池中的，因此为了便于 UI 操作，我们要有一个 Handler 将其切换到客户端主线程去执行。</p>
<p>代码如下：</p>
<pre><code>public class BookManagerActivity extends AppCompatActivity {
    private static final String TAG = &quot;BookManagerActivity&quot;;

    private static final int MESSAGE_NEW_BOOK_ARRIVED = 1;

    private IBookManager mRemoteBookManager;

    private Handler mHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what){
                case MESSAGE_NEW_BOOK_ARRIVED:
                    Log.d(TAG,&quot;收到新书：&quot;+msg.obj);
                    break;
                default:
                    super.handleMessage(msg);
            }
        }
    };


    private ServiceConnection mServiceConnection=new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
            IBookManager bookManager = IBookManager.Stub.asInterface(iBinder);
            try {
                mRemoteBookManager = bookManager;
                List&lt;Book&gt; bookList = bookManager.getBookList();
                Log.i(TAG,&quot;查询图书列表：&quot;+bookList.toString()+&quot;&quot;);
                bookManager.addBook(new Book(3,&quot;深入分析 Android 虚拟机&quot;));
                List&lt;Book&gt; newBbookList = bookManager.getBookList();
                Log.i(TAG,&quot;查询图书列表：&quot;+newBbookList.toString()+&quot;&quot;);
                bookManager.registerListener(mOnNewBookArrivedListener);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName componentName) {

        }
    };

    private IOnNewBookArrivedListener mOnNewBookArrivedListener = new IOnNewBookArrivedListener.Stub(){

        @Override
        public void onNewBookArrived(Book book) throws RemoteException {
            mHandler.obtainMessage(MESSAGE_NEW_BOOK_ARRIVED,book)
                    .sendToTarget();
        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_book_manager);
        Intent intent =new Intent(this,BookManagerService.class);
        bindService(intent,mServiceConnection,BIND_AUTO_CREATE);
    }

    @Override
    protected void onDestroy() {
        if (mRemoteBookManager!=null &amp;&amp; mRemoteBookManager.asBinder().isBinderAlive()){
            try {
                Log.d(TAG,&quot;客户端取消订阅&quot;+mOnNewBookArrivedListener);
                mRemoteBookManager.unregisterListener(mOnNewBookArrivedListener);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }
        super.onDestroy();
        unbindService(mServiceConnection);

    }
}
</code></pre><p>现在运行程序，就可以在控制台看到我们输出的 每五秒添加一本书，并通知客户端。  但当我们退出客户端的这个 activity 时我们会发现服务端找不到这个要解绑的 listener。 </p>
<p><img src="/2017/11/13/AIDL-实现进程通信/3.png" alt="图片加载失败"></p>
<p>这是因为 Binder 会把客户端传递过来的对象重新转化并生成一个新的对象。 虽然我们在注册和解注册过程中使用的是同一个客户端对象，但通过 Binder 传递到服务端后，却会产生两个对象。别忘了对象是不能跨进程传递的，对象的跨进程传递本质都是反序列化的过程。这就是 AIDL 的接口为什么都要实现 Parcelable 的原因。 </p>
<p>要实现解注册，我们先在服务端创建以一个 RemoteCallbackList 代替之前的 CopyOnWriteArrayList</p>
<pre><code> private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList=new RemoteCallbackList&lt;&gt;();
</code></pre><p>然后修改 registerListener 和 unregisterListener 方法 :</p>
<p><img src="/2017/11/13/AIDL-实现进程通信/4.png" alt="图片加载失败"></p>
<p>接着修改 onNewBookArrived（）方法，当有新书到时，我们就要通知已注册的 listener ：</p>
<p><img src="/2017/11/13/AIDL-实现进程通信/5.png" alt="图片加载失败"></p>
<p>到这里，BookManagerService 已经修改完毕，这时候我们就可以在 activity 关闭的解除注册了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>最后，我们再来回顾整理一下使用 AIDL 的基本步骤：</p>
<ol>
<li><p>创建 AIDL 接口。</p>
<p> 如果在 AIDL 使用了实体类，需要让这个实体类实现 Parcelable ，并且给它创建一个 AIDL格式 的声明文件。</p>
</li>
<li><p>创建一个 Service 作为服务端</p>
<p> 在服务端创建一个实现 AIDL接口的 Stub 对象的 Binder 。并且在 onBinder 中返回这个 Binder。</p>
</li>
<li><p>创建客户端</p>
<p> 在客户端首先绑定服务端，绑定成功后，将服务端返回的 Binder 对象转换成 AIDL 自动给我们生成的 IBookManager 类型：</p>
<p> IBookManager bookManager = IBookManager.Stub.asInterface(iBinder);</p>
<p> 然后用 bookManager 调用服务端的方法。</p>
</li>
</ol>
<blockquote>
<p>需要注意的是，在客户端调用服务端的方法时，因为方法是运行在服务端的 Binder线程池中，所以此时 客户端线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程阻塞在这里，而如果客户端线程又是 UI 线程，那么就会导致客户端 ANR。因此调用耗时的服务端的方法时，要在新的线程中执行。</p>
<p>同理，服务端调用客户端的耗时方法时，也要在新的线程中执行，因为这个方法同样是在客户端的 Binder 池中。</p>
</blockquote>

    </div>

    <div class="post-footer">   
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>  
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2017/12/31/2017-年终总结/" class="pre-post btn btn-default"><i class="fa fa-angle-left fa-fw"></i>上一篇</a>
    
    
        <a href="/2017/11/05/Messenger-的实现/" class="next-post btn btn-default">下一篇<i class="fa fa-angle-right fa-fw"></i></a>
    
</div>


    <div id="comments">
        
	
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMzA3NC85NjM2">
  <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];
         if (typeof LivereTower === 'function') { return; }
         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;
         e.parentNode.insertBefore(j, e);
     })(document, 'script');
  </script>
</div>


    </div>





                </main>
                
    <aside class="col-md-4 sidebar">
        
        
    <div class="widget">    
        <h3 class="title">搜索</h3>
        <div id="search-form">
            <div id="result-mask" class="hide"></div>
            <div class="search-area">
                
                    <input id="search-key" type="search" autocomplete="off" placeholder="搜点什么呢?">
                    <button type="button" class="search-form-submit" id="search-local">站内搜索</button>
                
                
            </div>
            <div id="result-wrap" class="hide">
                <div id="search-result"></div>
            </div>
            <div class="hide">
                <template id="search-tpl">
                    <div class="item">
                        <a href="/{path}" title="{title}">
                            <div class="title">{title}</div>
                            <div class="content">{content}</div>
                        </a>
                    </div>
                </template>
            </div>
        </div>
    </div>

        
        
    <div class="widget notification">
        <h3 class="title">网站公告</h3>
        <div>
            <p>主题Snippet v1.2.0版本已经上线！欢迎更新~ <br/>
主题下载：<a href="https://github.com/shenliyang/hexo-theme-snippet" title="fork me" target="_blank">Snippet主题</a> <br/>
<hr/>接受贡献，包括不限于提交问题与需求，修复代码。欢迎Pull Request<br/>支持主题：<a href="https://github.com/shenliyang/hexo-theme-snippet/stargazers">Star一下</a>
</p>
        </div>
    </div>

        
        
    <div class="widget">
      <h3 class="title">社交</h3> 
        <div class="content social">
            
	            <a href="//github.com/liurentian" rel="external nofollow" title="Github" target="_blank">
			    	<i class="git fa fa-git"></i>
			    </a>
            
	            <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=972377892@qq.com" rel="external nofollow" title="邮箱" target="_blank">
			    	<i class="envelope-o fa fa-envelope-o"></i>
			    </a>
            
	            <a href="http://wpa.qq.com/msgrd?v=3&uin=972377892&site=qq&menu=yes" rel="external nofollow" title="联系QQ" target="_blank">
			    	<i class="qq fa fa-qq"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="微博" target="_blank">
			    	<i class="weibo fa fa-weibo"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="QQ群" target="_blank">
			    	<i class="users fa fa-users"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="RSS" target="_blank">
			    	<i class="feed fa fa-feed"></i>
			    </a>
            
        </div>
    </div>


        
        
    <div class="widget">
        <h3 class="title">分类</h3>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/"><i class="fa" aria-hidden="true">Android</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link current" href="/categories/随笔/"><i class="fa" aria-hidden="true">随笔</i></a><span class="category-list-count">2</span></li></ul>
    </div>


        
        
    <div class="widget">
      <h3 class="title">归档</h3>
        <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/"><i class="fa" aria-hidden="true">十二月 2017</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/"><i class="fa" aria-hidden="true">十一月 2017</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/"><i class="fa" aria-hidden="true">十月 2017</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/"><i class="fa" aria-hidden="true">九月 2017</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/"><i class="fa" aria-hidden="true">七月 2017</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/"><i class="fa" aria-hidden="true">六月 2017</i></a><span class="archive-list-count">1</span></li></ul>
    </div>


        
        
  <div class="widget">
    <h3 class="title">标签云</h3>
    <div class="content tag-cloud">
        <a href="/tags/Android-View-专题/" style="font-size: 15px;">Android View 专题</a> <a href="/tags/Android-进程间通信/" style="font-size: 20px;">Android 进程间通信</a> <a href="/tags/JavaSE-多线程/" style="font-size: 10px;">JavaSE 多线程</a>
    </div>
  </div>


        
        
    <div class="widget">
        <h3 class="title">友链</h3>
        <div class="content friends-link">
        
            <a href="http://www.liurentian.com" class="fa" target="_blank">个人博客</a>
        
        </div>
    </div>


        
    </aside>

            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2017
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



	<script src="/js/search.js?rev=@@hash"></script>


<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>