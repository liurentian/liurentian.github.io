{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Binder 连接池","slug":"Binder-连接池","date":"2018-01-18T14:16:50.000Z","updated":"2018-01-22T05:32:56.281Z","comments":true,"path":"2018/01/18/Binder-连接池/","link":"","permalink":"http://yoursite.com/2018/01/18/Binder-连接池/","excerpt":"","text":"Binder 连接池的使用场景前面讲了不同的 IPC 方式，我们再来回顾一次 AIDL 的大致流程： 首先创建一个 Service 和 AIDL 的接口，接着创建一个类继承 AIDL 接口中的 Stub 类并实现 Stub 中的抽象方法，在 Service 中的 onBind 中返回这个类的对象，然后客户端就可以绑定服务端 Service ,建立连接后就可以远程访问服务端的方法了。 上述方式就是 AIDL 的常用方式，当两三个少量的业务需求看上去并没有什么问题，但是如果 AIDL 的接口使用的越来越多，我们难道还要跟着创建对应数量的 Service 么？ Service 是我们的四大组件之一，本身就是十分占用资源的。显然这种方式并不行。 针对这种情况，我们可以减少 Service 的数量，将所有的 AIDL 的接口放在同一个 Service 中去管理。 在这种情况下，它的工作模式是这样的，每个业务接口创建自己的 AIDL 接口并实现此接口，这个时候不同业务模块之间不能有耦合，所有细节我们单独开来，然后想服务端提供自己唯一的标识和其对应的 Binder 对象；对于服务端来说，只需要一个 Service 就可以了，服务端提供一个 queryBinder 接口，这个接口能根据业务模块的特征来返回相应的 Binder 对象给它们。 不同的业务模块拿到自己所需的 Binder 对象后就可以进行远程方法调用了。 由此可见，Binder 连接池的主要作用就是将每个 业务模块的的 Binder 请求统一转发到远程 Service 中去执行，从而避免了重复创建 Service 的过程，它的工作原理如图所示： Binder 连接池代码实现首先，提供两个 AIDL 接口（ISecurityCenter,ICompute）来模拟业务接口。 // ISecurityCenter.aidl package com.ydsd.binderdemo.binder; interface ISecurityCenter { String encrypt(String content); String decrypt(String password); } // ICompute.aidl package com.ydsd.binderdemo.binder; interface ICompute { int add(int a,int b); } 接着分别实现上面两个接口： public class SecurityCenterImpl extends ISecurityCenter.Stub{ private static final char SECRET_CODE = &#39;^&#39;; @Override public String encrypt(String content) throws RemoteException { char[] chars = content.toCharArray(); for (int i=0;i&lt;chars.length;i++){ chars[i] ^= SECRET_CODE; } return new String(chars); } @Override public String decrypt(String password) throws RemoteException { return encrypt(password); } } public class ComputeImpl extends ICompute.Stub { @Override public int add(int a, int b) throws RemoteException { return a+b; } } 到这里，业务模块的接口和实现都已经完成了，这里并没有给每个 AIDL 单独创建 Service ，接下来就是服务端和 Binder 的连接池了。 首先，给 Binder连接池创建 AIDL 接口 ： // IBinderPool.aidl package com.ydsd.binderdemo.binder; interface IBinderPool { IBinder queryBinder(int binderCode); } 接着，为 Binder 连接池创建远程 Service 并实现 IBinderPool。 远程 Service 如下： public class BinderPoolService extends Service{ private static final String TAG = &quot;BinderPoolService&quot;; private Binder mBinderPool = new BinderPool.BinderPoolImpl(); @Nullable @Override public IBinder onBind(Intent intent) { return mBinderPool; } @Override public void onCreate() { super.onCreate(); } @Override public void onDestroy() { super.onDestroy(); } } 下面就是 Binder 连接池的具体实现，在它的内部首先要先绑定远程服务，绑定成功后，客户端就可以通过它的 queryBinder 方法获取各自的 Binder 对象。 代码如下： public class BinderPool { private static final String TAG = &quot;BinderPool&quot;; public static final int BINDER_SECURITY_CENTER = 1; public static final int BINDER_COMPUTE = 0; public static final int BINDER_NONE = -1; private Context mContext; private IBinderPool mBinderPool; private static volatile BinderPool sInstance; private CountDownLatch mConnectBinderPoolCountDownLatch; private BinderPool(Context mContext) { this.mContext = mContext.getApplicationContext(); connectionBinderPoolService(); } public static BinderPool getInstance(Context context) { if (sInstance == null) { synchronized (BinderPool.class) { if (sInstance == null) { sInstance = new BinderPool(context); } } } return sInstance; } private synchronized void connectionBinderPoolService() { mConnectBinderPoolCountDownLatch = new CountDownLatch(1); Intent service = new Intent(mContext, BinderPoolService.class); mContext.bindService(service, mBinderPoolConnection, Context.BIND_AUTO_CREATE); try { mConnectBinderPoolCountDownLatch.await(); } catch (InterruptedException e) { e.printStackTrace(); } } public IBinder queryBinder(int binderCode) { IBinder binder = null; try { if (mBinderPool != null) { binder = mBinderPool.queryBinder(binderCode); } } catch (RemoteException e) { e.printStackTrace(); } return binder; } private ServiceConnection mBinderPoolConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) { mBinderPool = IBinderPool.Stub.asInterface(iBinder); try { mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient,0); } catch (RemoteException e) { e.printStackTrace(); } mConnectBinderPoolCountDownLatch.countDown(); } @Override public void onServiceDisconnected(ComponentName componentName) { } }; private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient() { @Override public void binderDied() { Log.d(TAG,&quot;binder 死亡&quot;); mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient,0); mBinderPool = null; connectionBinderPoolService(); } }; public static class BinderPoolImpl extends IBinderPool.Stub { @Override public IBinder queryBinder(int binderCode) throws RemoteException { IBinder binder = null; switch (binderCode){ case BINDER_SECURITY_CENTER: binder = new SecurityCenterImpl(); break; case BINDER_COMPUTE: binder = new ComputeImpl(); break; default: } return binder; } } } 最后是在 activity 中测试一下： public class BinderPoolActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_binder_pool); new Thread(new Runnable() { @Override public void run() { doWork(); } }).start(); } private void doWork(){ BinderPool binderPool = BinderPool.getInstance(this); IBinder securityBninder = binderPool.queryBinder(BinderPool.BINDER_SECURITY_CENTER); System.out.println(&quot;visit ISecurityCenter&quot;); ISecurityCenter mSecurityCenter = (ISecurityCenter) SecurityCenterImpl.asInterface(securityBninder); System.out.println(&quot;visit ISecurityCenter&quot;); String msg = &quot;helloworld - 安卓&quot;; System.out.println(&quot;content:&quot;+msg); try { String password = mSecurityCenter.encrypt(msg); System.out.println(&quot;encrypt:&quot;+password); System.out.println(&quot;decrypt:&quot;+mSecurityCenter.decrypt(password)); } catch (RemoteException e) { e.printStackTrace(); } IBinder computeBnder = binderPool.queryBinder(BinderPool.BINDER_COMPUTE); ICompute mCompute = ComputeImpl.asInterface(computeBnder); System.out.println(&quot;visit mCompute&quot;); try { System.out.println(&quot;3 + 5 = &quot;+mCompute.add(3,5)); } catch (RemoteException e) { e.printStackTrace(); } } }","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 进程间通信","slug":"Android-进程间通信","permalink":"http://yoursite.com/tags/Android-进程间通信/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Socket 实现进程通信","slug":"Socket-实现进程通信","date":"2018-01-16T04:48:15.000Z","updated":"2018-01-18T14:08:31.825Z","comments":true,"path":"2018/01/16/Socket-实现进程通信/","link":"","permalink":"http://yoursite.com/2018/01/16/Socket-实现进程通信/","excerpt":"","text":"概要实现 Socket 进行进程间通信。首先在远程 Service 建一个 TCP 服务，然后在主界面连接 TCP 服务。连接上了以后，我们给服务端发消息，服务端会随机回复我们。 使用 Socket 通信有两点要注意: 首先要声明权限： &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 不能在 UI 线程中访问网络。 正文1、服务端首先看一下服务端的设计，当 Service 启动时，会在线程建立 TCP 服务，这里监听的端口是 8688 端口。然后就可以等客户端的连接请求，当有客户端连接时就会生成一个新的 Socket ，通过每次创建的 Socket 就可以和不同的客户端通信了。代码如下： public class TCPServerService extends Service { private boolean isServiceDestoryed = false; private String[] mDefinedMessages = new String[]{ &quot;你好啊，哈哈&quot;, &quot;请问你叫什么名字啊&quot;, &quot;今天北京天气不错啊，shy&quot;, &quot;你知道么？ 我可是可以和多个人同时聊天的&quot;, &quot;给你讲个笑话吧，据说爱笑的人运气不会差，不知道真假&quot; }; @Override public void onCreate() { new Thread(new TcpServer()).start(); super.onCreate(); } @Override public void onDestroy() { isServiceDestoryed=true; super.onDestroy(); } @Nullable @Override public IBinder onBind(Intent intent) { return null; } private class TcpServer implements Runnable { @Override public void run() { ServerSocket serverSocket = null; try { //监听本地8688 端口 serverSocket = new ServerSocket(8688); } catch (IOException e) { System.err.println(&quot;建立TCP 服务失败，端口：8688&quot;); e.printStackTrace(); return; } while (!isServiceDestoryed){ try { final Socket client = serverSocket.accept(); System.out.println(&quot;accept&quot;); new Thread(){ @Override public void run() { try { responseClient(client); } catch (IOException e) { e.printStackTrace(); } } }.start(); } catch (IOException e) { e.printStackTrace(); } } } } private void responseClient(Socket client) throws IOException { //用于接受客户端消息 BufferedReader in =new BufferedReader(new InputStreamReader(client.getInputStream())); //用于向服务端发送消息 PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(client.getOutputStream())),true); out.println(&quot;欢迎来到聊天室&quot;); while (!isServiceDestoryed){ String str = in.readLine(); System.out.println(&quot;来自客户端的消息：&quot;+str); if (str == null){ break; } int i=new Random().nextInt(mDefinedMessages.length); String msg = mDefinedMessages[i]; out.println(msg); System.out.print(&quot;发送：&quot;+msg); } System.out.print(&quot;客户端退出&quot;); //关闭流 if (out!=null){ out.close(); } if (in!=null){ in.close(); } client.close(); } } 最后记得让服务端运行在独立的进程中。 2、客户端在客户端启动时，在onCreate（） 中开启一个线程去连接服务端 Socket。连接成功后，通过 while 不断的去读取服务端发送过来的信息。 代码如下： public class TCPClientActivity extends AppCompatActivity implements View.OnClickListener { private static final int MESSAGE_RECEIVE_NEW_MSG = 1; private static final int MESSAGE_SOCKET_CONNECT = 2; private TextView mMessageTextView; private EditText mMessageEditText; private Socket mClientSocket; private PrintWriter mPrintWriter; private Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { switch (msg.what){ case MESSAGE_RECEIVE_NEW_MSG: mMessageTextView.setText(mMessageTextView.getText()+(String)msg.obj); break; case MESSAGE_SOCKET_CONNECT: // mSendButton.setEnable(true); break; default: super.handleMessage(msg); } } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_tcpclient); mMessageTextView = (TextView) findViewById(R.id.msg_container); mMessageEditText = (EditText) findViewById(R.id.msg); findViewById(R.id.send).setOnClickListener(this); Intent intent = new Intent(this,TCPServerService.class); startService(intent); new Thread(new Runnable() { @Override public void run() { connectTCPServer(); } }).start(); } private void connectTCPServer() { Socket socket = null; while (socket == null){ try { socket = new Socket(&quot;localhost&quot;,8688); mClientSocket = socket; mPrintWriter = new PrintWriter(new BufferedWriter (new OutputStreamWriter(socket.getOutputStream())) ,true); mHandler.sendEmptyMessage(MESSAGE_SOCKET_CONNECT); System.out.println(&quot;连接服务端成功&quot;); } catch (IOException e) { SystemClock.sleep(1000); System.out.println(&quot;连接服务端失败，正在重新连接&quot;); } } try { //读取服务端的数据 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); while (!TCPClientActivity.this.isFinishing()){ String msg = br.readLine(); System.out.println(&quot;收到消息:&quot;+msg); if (msg!=null){ String time = formatDateTime(System.currentTimeMillis()); final String showedMsg = &quot;server &quot; + time +&quot;:&quot; +msg + &quot;\\n&quot;; mHandler.obtainMessage(MESSAGE_RECEIVE_NEW_MSG,showedMsg) .sendToTarget(); } } System.out.println(&quot;quit..&quot;); if (mPrintWriter!= null){ mPrintWriter.close(); } if (br!=null){ br.close(); } socket.close(); } catch (IOException e) { e.printStackTrace(); } } @SuppressLint(&quot;SimpleDateFormat&quot;) private String formatDateTime(long time) { return new SimpleDateFormat(&quot;(HH:mm:ss)&quot;).format(new Date(time)); } @Override public void onClick(View view) { if (view.getId() == R.id.send){ final String msg =mMessageEditText.getText().toString(); if (!TextUtils.isEmpty(msg) &amp;&amp; mPrintWriter!=null){ mPrintWriter.println(msg); mMessageEditText.setText(&quot;&quot;); String time = formatDateTime(System.currentTimeMillis()); final String showedMsg = &quot;self &quot;+ time+&quot;:&quot;+msg + &quot;\\n&quot;; mMessageTextView.setText(mMessageTextView.getText()+showedMsg); } } } @Override protected void onDestroy() { if (mClientSocket!=null){ try { mClientSocket.shutdownOutput(); mClientSocket.close(); } catch (IOException e) { e.printStackTrace(); } } super.onDestroy(); } } 3、界面代码&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;TextView android:id=&quot;@+id/msg_container&quot; android:layout_width=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:layout_height=&quot;0dp&quot; /&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;Button android:id=&quot;@+id/send&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_width=&quot;wrap_content&quot; android:text=&quot;发送&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;EditText android:id=&quot;@+id/msg&quot; android:layout_toLeftOf=&quot;@id/send&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 进程间通信","slug":"Android-进程间通信","permalink":"http://yoursite.com/tags/Android-进程间通信/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"2017 年终总结","slug":"2017-年终总结","date":"2017-12-31T14:51:00.000Z","updated":"2018-01-02T08:16:10.387Z","comments":true,"path":"2017/12/31/2017-年终总结/","link":"","permalink":"http://yoursite.com/2017/12/31/2017-年终总结/","excerpt":"","text":"12-31号 晚上11点，2017年的最后一天。 这一年，从上课到上班、从点名到打卡、从花钱到挣钱、从自认为天下无敌到承认自己是傻逼。 这一年，像不喜欢动画片一样，对游戏突然少了很多兴趣。 这一年，其实没多大改变 总结一下年底开始做的三件事，也是我认为值得坚持下去的三件事： 工作。 工作的首要目的肯定是为了生存，不向家里要钱。但是我又一直想从无到有地写出一个 属于我的App在我真正毕业的时候。 正好借着这个平台，只希望我可以尽量把它做到更好。 专升本。 说起专升本，我自己都搞不懂。早些时候我妈就跟我说让我专升本，当时我是十分坚决的说我肯定不会升，上了还得浪费两年。 没想到才出校门没两个月，自己就乖乖报了名，至于原因我只能安慰自己说（上学只有这两年了，而工作则可能是你以后的一生）。 还记得17年之前，我跟周围的人总是会说：即使现在让我再去高三一年，我肯定还是不会好好学。但是从今年6月份开始，不知道怎么回事，突然感到十几年学的东西好像真的能排上用场，只可惜自己学到的太少。 如果我们从小学的东西都能够马上用到生活上，可能这会儿都成学霸了。 理财。 这两个字，在之前我是完全没想过，也不敢想的。因为我根本没有财可理。 但在上个单位的一个姐，让我重新了解了它，当我刚听懂她的科普后，我就知道了这就是我感兴趣的。 当然，现在我并算不上什么理财，只是在下班之余了解/关注了一些理财的新闻/公众号，最近也开始定投了一只基金，就当赞个零花钱。 这三件事都是刚刚开始下手的，前两件也都会在18年的6月份接近帷幕，正好也就是我第一篇 Hello world 中说的一年以后。 所以，2017并没有结束，一切才刚刚开始 2018，希望你能真正像别人看起来的一样努力。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[],"keywords":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}]},{"title":"AIDL 实现进程通信","slug":"AIDL-实现进程通信","date":"2017-11-13T14:21:24.000Z","updated":"2018-01-15T05:33:39.408Z","comments":true,"path":"2017/11/13/AIDL-实现进程通信/","link":"","permalink":"http://yoursite.com/2017/11/13/AIDL-实现进程通信/","excerpt":"","text":"前言首先我们先从客户端和服务端来了解AIDL的跨进程通信的过程。 1、服务端服务器首先要创建一个 Service 用来监听客户端的连接请求，然后创建一个 AIDL 文件，将暴露给客户端的这个接口在这个 AIDL 文件中声明，最后在 Service 中实现这个 AIDL 的接口即可。 2、客户端客户端要做的就是绑定服务端的 Service，绑定成功后，将服务端的返回的 Binder对象转换为 AIDl 接口所属的类型，接着就可以调用 AIDL 中的方法了。 正文下面来看看其实现的具体过程 1、创建 AIDL 接口 跟之前学习 Binder 时一样，创建了一个 .aidl 文件，里面声明了一个接口和两个接口方法。 // IBookManager.aidl package com.ydsd.binderdemo; import com.ydsd.binderdemo.Book; interface IBookManager { List&lt;Book&gt; getBookList(); void addBook(in Book book); } 这里需要注意的是，在AIDL中，只支持以下几种类型： 基本数据类型（int、long、char、boolean、double等）； String和CharSequence ; List : 只支持ArrayList，里面每个元素都必须被 AIDL 支持。 Map ： 只支持HaseMap ， 里面每个元素都必须被 AIDL 支持，包括 key 和 value。 Parcelable ： 所有实现了 Parcelable 的对象。 AIDL ：所有 AIDL 接口本身也可以在 AIDL 文件中使用。 在这6中类型中，其中自定义的 Parceable 对象和 AIDL 对象必须要显示的用 import 引进来，不管它们是否在一个包下。例如这个接口中用到了 Book 这个类，这个类是自定的 Parcelable 对象，所以必须新建一个 Book.aidl 文件并在里面声明 parcelable book 如下所示： // Book.aidl package com.ydsd.binderdemo; parcelable Book; 除此之外，AIDL 中除了基本类型，其他类型的参数必须标上方向：in、out、inout，in 表示输入型参数，out 表示输出型参数。另外 AIDL 中只支持方法，不支持声明静态常量。为了方便 AIDL 开发，建议把所有和 AIDL 相关的类和文件全部放在同一个包中。 2、远程服务端Service的实现上面讲述了如何定义 AIDL 接口，接下来我们就来实现这个接口，我们先创建一个 Service，称为 BookManagerService，代码如下： public class BookManagerService extends Service{ private static final String TAG = &quot;BMS&quot;; private CopyOnWriteArrayList&lt;Book&gt; mBookList =new CopyOnWriteArrayList&lt;&gt;(); private Binder mBinder =new IBookManager.Stub() { @Override public List&lt;Book&gt; getBookList() throws RemoteException { return mBookList; } @Override public void addBook(Book book) throws RemoteException { mBookList.add(book); } }; @Override public void onCreate() { super.onCreate(); mBookList.add(new Book(1,&quot;Android 开发艺术探索&quot;)); mBookList.add(new Book(2,&quot;第一行代码&quot;)); } @Nullable @Override public IBinder onBind(Intent intent) { return mBinder; } } 上面是一个服务端的典型实现，在 onCreate() 中，我们首先添加了两本书，然后创建了一个 Binder 对象并在 onBinder() 中返回它，这个对象继承 IBookManager.Stub 并实现了它内部的 AIDL 方法。 需要注意的是，由于 AIDL 方法是在服务端的 Binder 线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程并发访问的现象，所以要在 AIDL 中处理线程同步，所以这里使用 CopyOnWriteArrayList 来进行线程的自动同步。 然后需要给这个 Service 指定固定的进程： &lt;service android:name=&quot;.aidl.BookManagerService&quot; android:process=&quot;:remote&quot;/&gt; 3、客户端的实现客户端首先要绑定 Service ，绑定成功后将获取服务端返回的 Binder 转换成 AIDL 接口，然后根据这个接口去调用服务端远程的方法。代码如下： public class BookManagerActivity extends AppCompatActivity { private static final String TAG = &quot;BookManagerActivity&quot;; private ServiceConnection mServiceConnection=new ServiceConnection() { @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) { IBookManager bookManager = IBookManager.Stub.asInterface(iBinder); try { List&lt;Book&gt; bookList = bookManager.getBookList(); Log.i(TAG,&quot;查询图书列表：&quot;+bookList.toString()); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName componentName) { } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_book_manager); Intent intent =new Intent(this,BookManagerService.class); bindService(intent,mServiceConnection,BIND_AUTO_CREATE); } @Override protected void onDestroy() { super.onDestroy(); unbindService(mServiceConnection); } } 到这里，我们就完成了使用 AIDL 进行 IPC。接着我们在调用一下另一个接口 addBook（）往服务器添加一本图书试试。 运行程序，发现addBook（）成功的被调用了。 4、实现观察者模式到这里，我们已经实现了 AIDL 的基本功能，但 AIDL 远没有看上去的这么简单。 接下来，我们来讨论并实现一种新的场景：即用户（客户端）不用时不时的去查询图书列表，当图书列表有新书添加的时候会自动的通知对这本图书感兴趣的人。这就是一种典型的观察者模式。 每个感兴趣的用户都观察新书，当有新书到时，图书馆就通知每个对这本书感兴趣的用户。 首先，我们先创建一个监听新书的接口，由于 AIDL 中不支持普通接口，所以我们需要创建一个 AIDL 接口。 代码如下: // IOnNewBookArrivedListener.aidl package com.ydsd.binderdemo.aidl; import com.ydsd.binderdemo.aidl.Book; interface IOnNewBookArrivedListener { void onNewBookArrived(in Book book); } 然后给 IBookManager.aidl 接口，增加注册和取消监听的方法。 接下来，去服务端实现我们在 IBookManager.aidl 中新增的这两个方法。然后再在一个线程中每五秒添加一本新书，并通知每个对它感兴趣的人。 public class BookManagerService extends Service{ private static final String TAG = &quot;BMS&quot;; private AtomicBoolean mIsServiceDestory = new AtomicBoolean(false); private CopyOnWriteArrayList&lt;Book&gt; mBookList =new CopyOnWriteArrayList&lt;&gt;(); private CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt; mListenerList=new CopyOnWriteArrayList&lt;&gt;(); private Binder mBinder =new IBookManager.Stub() { @Override public List&lt;Book&gt; getBookList() throws RemoteException { return mBookList; } @Override public void addBook(Book book) throws RemoteException { mBookList.add(book); } @Override public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException { if (!mListenerList.contains(listener)){ mListenerList.add(listener); }else { Log.d(TAG,&quot;已经存在&quot;); } Log.d(TAG,&quot;注册的listener数：&quot;+mListenerList.size()); } @Override public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException { if (mListenerList.contains(listener)){ mListenerList.remove(listener); }else{ Log.d(TAG,&quot;没有找到&quot;); } Log.d(TAG,&quot;解绑成功，当前绑定用户：&quot;+mListenerList.size()); } }; @Override public void onCreate() { super.onCreate(); mBookList.add(new Book(1,&quot;Android 开发艺术探索&quot;)); mBookList.add(new Book(2,&quot;第一行代码&quot;)); new Thread(new ServiceWorker()).start(); } @Override public void onDestroy() { mIsServiceDestory.set(true); super.onDestroy(); } @Nullable @Override public IBinder onBind(Intent intent) { return mBinder; } private class ServiceWorker implements Runnable{ @Override public void run() { //在后台执行。。。。 while(!mIsServiceDestory.get()){ try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } int bookId=mBookList.size()+1; Book newBook =new Book(bookId,&quot;新书&quot;+bookId); try { onNewBookArrived(newBook); Log.d(TAG,&quot;添加了一本新书&quot;); } catch (RemoteException e) { e.printStackTrace(); } } } } private void onNewBookArrived(Book newBook) throws RemoteException { mBookList.add(newBook); Log.d(TAG,&quot;新书到了，通知了&quot;+mListenerList.size()+&quot;位用户&quot;); for (int i=0;i&lt;mListenerList.size();i++){ IOnNewBookArrivedListener listener=mListenerList.get(i); Log.d(TAG,&quot;通知了用户：&quot;+listener); listener.onNewBookArrived(newBook); } } } 最后，我们还需要修改客户端代码，首先客户端要注册 IOnNewBookArrivedListener 到远程服务，这样当有新书时才能通知到客户端。 同时，要在 activity 退出时 解除这个注册。 另一方面，当有新书到时， onNewBookArrived 方法是运行在客户端的 Binder 线程池中的，因此为了便于 UI 操作，我们要有一个 Handler 将其切换到客户端主线程去执行。 代码如下： public class BookManagerActivity extends AppCompatActivity { private static final String TAG = &quot;BookManagerActivity&quot;; private static final int MESSAGE_NEW_BOOK_ARRIVED = 1; private IBookManager mRemoteBookManager; private Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { switch (msg.what){ case MESSAGE_NEW_BOOK_ARRIVED: Log.d(TAG,&quot;收到新书：&quot;+msg.obj); break; default: super.handleMessage(msg); } } }; private ServiceConnection mServiceConnection=new ServiceConnection() { @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) { IBookManager bookManager = IBookManager.Stub.asInterface(iBinder); try { mRemoteBookManager = bookManager; List&lt;Book&gt; bookList = bookManager.getBookList(); Log.i(TAG,&quot;查询图书列表：&quot;+bookList.toString()+&quot;&quot;); bookManager.addBook(new Book(3,&quot;深入分析 Android 虚拟机&quot;)); List&lt;Book&gt; newBbookList = bookManager.getBookList(); Log.i(TAG,&quot;查询图书列表：&quot;+newBbookList.toString()+&quot;&quot;); bookManager.registerListener(mOnNewBookArrivedListener); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName componentName) { } }; private IOnNewBookArrivedListener mOnNewBookArrivedListener = new IOnNewBookArrivedListener.Stub(){ @Override public void onNewBookArrived(Book book) throws RemoteException { mHandler.obtainMessage(MESSAGE_NEW_BOOK_ARRIVED,book) .sendToTarget(); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_book_manager); Intent intent =new Intent(this,BookManagerService.class); bindService(intent,mServiceConnection,BIND_AUTO_CREATE); } @Override protected void onDestroy() { if (mRemoteBookManager!=null &amp;&amp; mRemoteBookManager.asBinder().isBinderAlive()){ try { Log.d(TAG,&quot;客户端取消订阅&quot;+mOnNewBookArrivedListener); mRemoteBookManager.unregisterListener(mOnNewBookArrivedListener); } catch (RemoteException e) { e.printStackTrace(); } } super.onDestroy(); unbindService(mServiceConnection); } } 现在运行程序，就可以在控制台看到我们输出的 每五秒添加一本书，并通知客户端。 但当我们退出客户端的这个 activity 时我们会发现服务端找不到这个要解绑的 listener。 这是因为 Binder 会把客户端传递过来的对象重新转化并生成一个新的对象。 虽然我们在注册和解注册过程中使用的是同一个客户端对象，但通过 Binder 传递到服务端后，却会产生两个对象。别忘了对象是不能跨进程传递的，对象的跨进程传递本质都是反序列化的过程。这就是 AIDL 的接口为什么都要实现 Parcelable 的原因。 要实现解注册，我们先在服务端创建以一个 RemoteCallbackList 代替之前的 CopyOnWriteArrayList private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList=new RemoteCallbackList&lt;&gt;(); 然后修改 registerListener 和 unregisterListener 方法 : 接着修改 onNewBookArrived（）方法，当有新书到时，我们就要通知已注册的 listener ： 到这里，BookManagerService 已经修改完毕，这时候我们就可以在 activity 关闭的解除注册了。 小结最后，我们再来回顾整理一下使用 AIDL 的基本步骤： 创建 AIDL 接口。 如果在 AIDL 使用了实体类，需要让这个实体类实现 Parcelable ，并且给它创建一个 AIDL格式 的声明文件。 创建一个 Service 作为服务端 在服务端创建一个实现 AIDL接口的 Stub 对象的 Binder 。并且在 onBinder 中返回这个 Binder。 创建客户端 在客户端首先绑定服务端，绑定成功后，将服务端返回的 Binder 对象转换成 AIDL 自动给我们生成的 IBookManager 类型： IBookManager bookManager = IBookManager.Stub.asInterface(iBinder); 然后用 bookManager 调用服务端的方法。 需要注意的是，在客户端调用服务端的方法时，因为方法是运行在服务端的 Binder线程池中，所以此时 客户端线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程阻塞在这里，而如果客户端线程又是 UI 线程，那么就会导致客户端 ANR。因此调用耗时的服务端的方法时，要在新的线程中执行。 同理，服务端调用客户端的耗时方法时，也要在新的线程中执行，因为这个方法同样是在客户端的 Binder 池中。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 进程间通信","slug":"Android-进程间通信","permalink":"http://yoursite.com/tags/Android-进程间通信/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Messenger 的实现","slug":"Messenger-的实现","date":"2017-11-05T05:14:31.000Z","updated":"2018-01-10T14:09:04.238Z","comments":true,"path":"2017/11/05/Messenger-的实现/","link":"","permalink":"http://yoursite.com/2017/11/05/Messenger-的实现/","excerpt":"","text":"前言Messenger 的使用方法很简单，它对 AIDL 做了封装，使得我们可以更简单的进行进程间的通信。同时，因为它一次处理一个请求，因此在服务端我们不用考虑线程同步的问题，这是因为服务端不存在并发执行的情形。实现一个 Messenger 有如下几个步骤，分为服务端和客户端。 服务端进程 首先我们需要在服务端创建一个 Service 来处理客户端的连接请求。同时创建一个 Handler 并通过它来创建一个 Messenger 对象，然后在 Service 中的 onBind 中返回这个 Messenger 对象底层的 Binder 即可。 客户端进程 客户端进程中，首先要绑定服务端的 Service，绑定成功后用服务端返回的 IBinder 创建一个 Messenger，通过这个 Messenger 就可以向服务端发送消息了，发送的消息类型为 Message 对象。如果需要服务端能够回应客户端，就和服务端一样，我们还需要在创建一个 Handler 并创建一个新的 Messenger，并把这个 Messenger 对象通过 Message 的 replyTo 参数传递给服务端，服务端通过这个 replyTo 参数就可以回应客户端。 目录通过下面两个例子理解 Messenger 的使用 简单的服务端不需要回应客户端的例子： 服务端回应客户端 正文1、简单的服务端不需要回应客户端的实现首先看服务端，服务端创建了一个 MessengerHandler 用来处理客户端发送的消息，接着创建了一个 Messenger 对象并和 MessengerHandler 相关联。最后在 onBind 里面返回 mMessenger 对象里面的 Binder。 public class MessengerService extends Service { private static final String TAG = &quot;MessengerService&quot;; private static class MessengerHandler extends Handler { @Override public void handleMessage(Message msg) { switch (msg.what) { case MyConstant.MSG_FROM_CLIENT: Log.i(TAG, &quot;收到客户端的消息:&quot; + msg.getData().getString(&quot;msg&quot;)); break; default: super.handleMessage(msg); } } } private final Messenger mMessenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) { return mMessenger.getBinder(); } } 然后，注册Service，让它运行在不同的进程中。作为服务端 &lt;service android:name=&quot;.messenger.MessengerService&quot; android:process=&quot;:remote&quot; /&gt; 接下来看看客户端的实现，客户端的实现也很简单，首先要绑定远程进程的服务 MessengerService，在绑定成功后，根据服务端返回的 Binder 对象创建 Messenger 对象并使用此对象向服务端发送消息。这样程序运行时，服务端就会收到客户端发送的消息。 public class MessengerActivity extends AppCompatActivity { private static final String TAG = &quot;MessengerActivity&quot;; private Messenger mService; private ServiceConnection mConnection=new ServiceConnection() { @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) { mService=new Messenger(iBinder); Message msg = Message.obtain(null, MyConstant.MSG_FROM_CLIENT); Bundle data=new Bundle(); data.putString(&quot;msg&quot;,&quot;你好，这里是客户端!&quot;); msg.setData(data); try { mService.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName componentName) { } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger); Intent intent =new Intent(this,MessengerService.class); bindService(intent,mConnection, Context.BIND_AUTO_CREATE); } @Override protected void onDestroy() { unbindService(mConnection); super.onDestroy(); } } 2、服务端回应客户端消息上面的例子演示了如何在服务端接收客户端发送的消息，但有时候我们可能还需要回应客户端。下面我们来看看怎么给客户端回复消息。 首先看服务端的修改，服务端只需要修改 MessengerHandler，在接受到消息时，通过消息的 replyTo 得到客户端的 Messenger 对象，给客户端回复一条消息。代码如下: private static class MessengerHandler extends Handler { @Override public void handleMessage(Message msg) { switch (msg.what) { case MyConstant.MSG_FROM_CLIENT: Log.i(TAG, &quot;收到客户端的消息:&quot; + msg.getData().getString(&quot;msg&quot;)); Messenger client = msg.replyTo; Message replyMsg = Message.obtain(null, MyConstant.MSG_FROM_SERVER); Bundle bundle=new Bundle(); bundle.putString(&quot;reply&quot;,&quot;你的消息我已收到，稍后回复你。&quot;); replyMsg.setData(bundle); try { client.send(replyMsg); } catch (RemoteException e) { e.printStackTrace(); } break; default: super.handleMessage(msg); } } } 接下来看客户端的代码的修改，为了接受服务端回复的消息，客户端也要准备一个 Messenger 和 Handler。如下所示： 除了上述修改，我们还需要在客户端发送消息时，需要把接受服务端消息的 Messenger 通过 Message.replyTo 参数发送给服务端。如下所示: 到此为止，Messenger 的进程间通信就算完成了，下面我们结合一张 Messenger 的工作原理图来更好的理解 Messenger。 小结到这里结合最后这张 Messenger 的工作原理图，我们来整理一下代码的思路。 新建一个 Service 运行在 独立进程中，模拟服务端。 Service 中有一个 Messenger 用来接收客户端的消息并在 MessengerHandler 中处理。 这个 Messenger 在 onBind（） 中被返回。 在默认进程中 绑定服务端的 Service，再绑定成功时用返回的 Messenger 给服务端发送消息。 如何客户端需要接受 服务端返回的消息，则需要在客户端 创建一个用来 获取服务端消息的 Messenger 及 MessengerHander 。并且在给服务端发送消息时将这个 获取服务端消息的Messenger 通过 msg.reply = Messenger 的方式发送过去。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 进程间通信","slug":"Android-进程间通信","permalink":"http://yoursite.com/tags/Android-进程间通信/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android IPC机制学习笔记(三)","slug":"Android-IPC机制学习笔记-三","date":"2017-11-02T16:00:00.000Z","updated":"2018-01-18T14:20:30.509Z","comments":true,"path":"2017/11/03/Android-IPC机制学习笔记-三/","link":"","permalink":"http://yoursite.com/2017/11/03/Android-IPC机制学习笔记-三/","excerpt":"","text":"前言 前两节学习了 IPC 的几个基础知识：序列化和 Binder ，本节开始详细分析各种跨进程通信方式。具体方式有很多，比如可以通过在 Intent 中附加 extras 来传递信息，或者通过共享文件的方式来共享数据，还可以采用 Binder 的方式来跨进程通信，另外，ContentProvider 天生就是支持跨进程访问的，因此我们也可以采用它来进行 IPC。此外，进行网络通信也是可以实现数据传递的，所以 Socket 也是可以实现 IPC。 上面说的各种方法都能实现IPC，他们在使用方法和侧重点上却有很大区别，下面来一一进行展开分析。 目录 使用 Bundle 使用文件共享 使用 Messenger 使用 AIDL 使用 ContentProvider 使用 Socket 正文1、使用 Bundle我们知道，四大组件中的三大组件（Activity，Service，Receiver）都是支持在 Intent 中传递 Bundle 数据的。由于 Bundle 实现了 Parcelable 接口，所以它可以方便的在不同的进程间传输。基于这一点，当我们在一个进程中启动了另一个进程的 Activity、Service 和 Receiver，我们就可以在 Bundle 中附加我们需要传输给远程进程的信息并通过 Intent 发送出去。（当然传输的数据必须能够被序列化，比如基本类型、实现了 Parcelable 或 Serializable 接口的对象以及一些 Bundle 所支持的对象）。 除了直接传递它还有一个特殊场景。比如 A 进程正在进行一个计算，计算完成后它要启动 B 进程并把结果传输给B进程的一个组件，遗憾的是这个计算结果不支持放入 Bundle，因此不能用 Intent 来传输。，这个时候我们可以用 Intent 来开启 B 进程的一个 Service 组件（比如 IntentService） ，让 Service 在后台计算，计算完在启动 B 进程的组件直接获取结果。 2、使用文件共享共享文件就是两个进程通过读/写同一个文件来交换数据，比如A进程把数据写入一个文件，B进程通过读取这个文件来获取数据。通过共享文件这种方式来共享数据对文件格式是没有具体要求的，比如可以是文本文件，也可以是 XML 文件，只要读/写双方约定数据格式即可。 3、使用 MessengerMessenger 可以翻译为信使，通过它可以在不同进程中传递Message 对象，在Message 中放入我们要传递的数据，就可以实现数据的进程间传递了。Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，从它的构造方法中可以看出。 public Messenger (Handler target){ mTarget = target.getIMessenger(); } public Messenger (IBinder target){ mTarget = IMessenger.Stub.asInterface(target); } 具体的实现请看 Messenger 实现进程通信 4、使用 AIDL上面讲到 Messenger，我们先来回顾一下 Messenger 的特点，Messenger 是以串行的方式一个一个地来处理客户端的消息的，如果并发请求较多时，Messenger 显然不太合适，而且 Messenger 只是用来传递消息的，不能跨进程调用服务端的方法，这时候就需要使用 AIDL 来解决问题了。 AIDL 也是 Messenger 的底层实现。因此 Messenger 的本质也是 AIDL，只不过系统给我们做了封装从而方便上层调用。 具体的实现请看 AIDL 实现进程通信 5、使用 ContentProvider6、使用 SocketSocket 也称 “套接字”,是网络通信中的概念。它分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层的 TCP 和 UDP 协议。 TCP 协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过 “三次握手” 才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性； 而 UDP 是无连接的，提供不稳定的单向通信功能，当然 UDP 也可以实现双向通信功能。 在性能上 UDP 具有更好的效率，其缺点是不一定能保证数据一定能正确传输。尤其在网络拥塞的情况下。 关于 Socket 和 TCP UDP就介绍到这，下面我们看一下 Socket 实现进程通信 小结一张图分析一下6中方式的优缺点：","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 进程间通信","slug":"Android-进程间通信","permalink":"http://yoursite.com/tags/Android-进程间通信/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android IPC机制学习笔记(二)","slug":"Android-IPC机制学习笔记-二","date":"2017-10-18T16:00:00.000Z","updated":"2018-01-07T08:35:05.134Z","comments":true,"path":"2017/10/19/Android-IPC机制学习笔记-二/","link":"","permalink":"http://yoursite.com/2017/10/19/Android-IPC机制学习笔记-二/","excerpt":"","text":"前言前面已经简单了解了 Binder 的概念及用途。下面我们就下面两点来深入了解一下。 目录1.通过 AIDL 分析 Binder 2.手动实现 Binder 一、通过 AIDL 分析 Binder首先新建一个 AIDL 示例 1、新建一个 Book.java 表示一个图书信息的类，实现 Parcelable 接口 public class Book implements Parcelable { private int bookId; private String bookName; public Book(int bookId, String bookName) { this.bookId = bookId; this.bookName = bookName; } protected Book(Parcel in) { bookId = in.readInt(); bookName = in.readString(); } public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() { @Override public Book createFromParcel(Parcel in) { return new Book(in); } @Override public Book[] newArray(int size) { return new Book[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel parcel, int i) { parcel.writeInt(bookId); parcel.writeString(bookName); } } 2、创建 Book.aidl，Book.aidl 是 Book 类在 AIDL 中的声明。 // Book.aidl.aidl package com.ydsd.binderdemo.aidl; parcelable Book; 3、创建 IBookManager.aidl, IBookManager.aidl 是我们定义的一个接口，里面有两个方法：getBookList 和 addBook。 // IBookManager.aidl package com.ydsd.binderdemo.aidl; // 注意即使 Book 跟 IBookmanager 在同一个包中，也需要引入。 import com.ydsd.binderdemo.aidl.Book; interface IBookManager { List&lt;Book&gt; getBookList(); void addBook(in Book book); } 到此为止，AIDL就创建完成了，这时候我们用 AndroidStudio 编译项目， 编译过后，系统会自动给我们在 gen 目录下的 aidl 包中为 IBookManager.aidl 生成一个叫 IBookManager.java 的 Binder 类。这就是 AIDL 的特殊之处。 最后看一下项目目录: 4、编译项目, 找到并分析 IBookManager.java 类 下面我们找到 gen 目录下的 aidl 包中系统为我们生成的的 IBookManager.java 类。来分析一下。 public interface IBookManager extends android.os.IInterface { /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.ydsd.binderdemo.aidl.IBookManager { private static final java.lang.String DESCRIPTOR = &quot;com.ydsd.binderdemo.aidl.IBookManager&quot;; /** * Construct the stub at attach it to the interface. */ public Stub() { this.attachInterface(this, DESCRIPTOR); } /** * Cast an IBinder object into an com.ydsd.binderdemo.aidl.IBookManager interface, * generating a proxy if needed. */ public static com.ydsd.binderdemo.aidl.IBookManager asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.ydsd.binderdemo.aidl.IBookManager))) { return ((com.ydsd.binderdemo.aidl.IBookManager) iin); } return new com.ydsd.binderdemo.aidl.IBookManager.Stub.Proxy(obj); } @Override public android.os.IBinder asBinder() { return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(DESCRIPTOR); return true; } case TRANSACTION_getBookList: { data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.ydsd.binderdemo.aidl.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; } case TRANSACTION_addBook: { data.enforceInterface(DESCRIPTOR); com.ydsd.binderdemo.aidl.Book _arg0; if ((0 != data.readInt())) { _arg0 = com.ydsd.binderdemo.aidl.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.addBook(_arg0); reply.writeNoException(); return true; } } return super.onTransact(code, data, reply, flags); } private static class Proxy implements com.ydsd.binderdemo.aidl.IBookManager { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } @Override public java.util.List&lt;com.ydsd.binderdemo.aidl.Book&gt; getBookList() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.ydsd.binderdemo.aidl.Book&gt; _result; try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.ydsd.binderdemo.aidl.Book.CREATOR); } finally { _reply.recycle(); _data.recycle(); } return _result; } @Override public void addBook(com.ydsd.binderdemo.aidl.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } } } static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); } public java.util.List&lt;com.ydsd.binderdemo.aidl.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(com.ydsd.binderdemo.aidl.Book book) throws android.os.RemoteException; } 可以看到系统根据IBookManager.aidl 系统给我们生成了 IBookManager.java 这个类。 IBookManager.java 继承了 IInterface 接口，同时它自己还是个接口，所有可以在 Binder 中传输的类都要继承 IInterface 接口。 按结构来分析的话，首先它声明了两个方法 getList 和 addBook。 显然这就是我们在IBookManager.aidl 中声明的方法。接着它声明了两个整形的 id 用于分别标识这两个方法。这两个id用于标识在 transact 过程中客户端所请求的到底是哪个方法，接着它声明了一个stub 内部类，这个Stub就是一个 Binder 类，当客户端和服务端都位于同一进程中，方法调用不会走跨进程的 transact 过程，而当两者位于不同进程中，方法调用需要走 transact 过程，这个逻辑由 Stub 的内部代理类 Proxy 来完成。 这么来看 这个接口的核心实现就是它的内部类 Stub 和 Stub 的内部代理类 Proxy。 下面来详细看这两个类的方法含义。 DESCRIPTOR: —-&gt; Binder的唯一标识，一般用当前类名表示。 asInterface(android.os.IBinder obj): —-&gt; 用于将服务端的Binder 对象转换成客户端所需的AIDL 接口类型的对象。这种转换过程是区分进程的，如果客户端和服务端在统一进程，那么返回的就是 Stub 对象本身，否则返回的是系统封装好的 Stub.proxy 对象。 asBinder: —-&gt; 此方法用于返回当前Binder对象。 onTransact: —-&gt; 这个方法运行在服务端的线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为 public Boolean onTransact(int code,Parcel data,Parcel reply,int flags)。服务端通过code 可以确定客户端所请求的目标方法是什么，接着从data 里面取出目标方法所需的参数，然后执行目标方法。等目标方法执行完毕后，就向reply写入返回值。需要注意的是，如果此方法返回false，那么客户端的请求会失败，我们可以利用这个特性来做权限验证。 Proxy# getBookList/addBook: —-&gt; 这个方法运行在客户端，当客户端调用此方法时，它的内部是这样实现的： 首先创建该方法所需要的输入型Parcel 对象 _data、输出型Parcel 对象 __reply、和返回值对象List； 然后把该方法的参数信息写入_data中；接着调用transact方法来发起RPC（远程过程调用）请求，同时当前线程挂起；然后服务端的onTransact 方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply 中取出RPC过程返回的结果；最后返回_reply 中的数据。 通过对上面方法的分析，我们应该已经了解 Binder 机制了。但是有两点需要注意：首先，当客户端发起远程请求时，由于当期线程会被挂起直至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程中发起此请求；其次，由于服务端的Binder 方法运行在Binder的线程池中，所以Binder方法不管是否耗时都应该采用同步的方法去实现，因为它已经运行在一个线程池中了。为了更好地说明Binder 下面有一个Binder的工作机制图。 二、手动实现 Binder从上面的分析过程来看，我们完全可以不使用AIDL 文件即可实现Binder，之所以提供AIDL文件，是为了方便系统为我们生成代码。系统根据AIDL 文件生成java 文件的格式是固定的，我们可以抛开AIDL文件直接写一个Binder出来。 根据上面的思想，手动实现一个Binder可以通过以下步骤来完成： (1) 声明一个 AIDL 性质的接口，只需要继承 IInterface 接口即可，IInterface 接口中只有一个 asBinder 方法。代码如下所示： public interface IBookManager extends IInterface{ static final String DESCRIPTOR =&quot;com.aidldemo.IBookManager&quot;; static final int TRANSACTION_getBookList= IBinder.FIRST_CALL_TRANSACTION+0; static final int TRANSACTION_addBook=IBinder.FIRST_CALL_TRANSACTION+1; public List&lt;Book&gt; getBookList() throws RemoteException; public void addBook(Book book) throws RemoteException; } (2) 实现Stub 类和Stub类中的Proxy代理类，这段代码只需要参考系统生成的代码即可，代码如下图所示： /** * IBookManager 的内部类 相当于 Stub */ public class IBookManagerImpl extends Binder implements IBookManager { public IBookManagerImpl() { this.attachInterface(this,DESCRIPTOR); } public static IBookManager asInterface(IBinder obj){ if (obj==null){ return null; } IInterface iin=obj.queryLocalInterface(DESCRIPTOR); if ((iin!=null) &amp;&amp; (iin instanceof IBookManager) ){ return (IBookManager) iin; } return new IBookManagerImpl.Proxy(obj); } @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException { switch (code){ case INTERFACE_TRANSACTION: { reply.writeString(DESCRIPTOR); return true; } case TRANSACTION_addBook: { data.enforceInterface(DESCRIPTOR); Book _argo; if (0!=data.readInt()){ _argo=Book.CREATOR.createFromParcel(data); }else { _argo=null; } this.addBook(_argo); reply.writeNoException(); return true; } case TRANSACTION_getBookList: { data.enforceInterface(DESCRIPTOR); List&lt;Book&gt; result=this.getBookList(); reply.writeNoException(); reply.writeTypedList(result); return true; } } return super.onTransact(code, data, reply, flags); } @Override public List&lt;Book&gt; getBookList() throws RemoteException { return null; } @Override public void addBook(Book book) throws RemoteException { } @Override public IBinder asBinder() { return this; } private static class Proxy implements IBookManager{ private IBinder mRemote; Proxy(IBinder remote){ this.mRemote=remote; } public String getInterfaceDescriptor(){ return DESCRIPTOR; } @Override public List&lt;Book&gt; getBookList() throws RemoteException { Parcel data=Parcel.obtain(); Parcel reply=Parcel.obtain(); List&lt;Book&gt; result; try { data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(TRANSACTION_getBookList,data,reply,0); reply.readException(); result=reply.createTypedArrayList(Book.CREATOR); }finally { reply.recycle(); data.recycle(); } return result; } @Override public void addBook(Book book) throws RemoteException { Parcel data=Parcel.obtain(); Parcel reply=Parcel.obtain(); try { data.writeInterfaceToken(DESCRIPTOR); if (book!=null){ data.writeInt(1); book.writeToParcel(data,0); }else { data.writeInt(0); } mRemote.transact(TRANSACTION_addBook,data,reply,0); }finally { reply.recycle(); data.recycle(); } } @Override public IBinder asBinder() { return mRemote; } } }","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 进程间通信","slug":"Android-进程间通信","permalink":"http://yoursite.com/tags/Android-进程间通信/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android IPC机制学习笔记(一)","slug":"Android-IPC机制学习笔记-一","date":"2017-10-08T16:00:00.000Z","updated":"2018-01-03T05:25:16.103Z","comments":true,"path":"2017/10/09/Android-IPC机制学习笔记-一/","link":"","permalink":"http://yoursite.com/2017/10/09/Android-IPC机制学习笔记-一/","excerpt":"","text":"一、Android IPC简介 IPC机制（inter-process-Communication），进程间通信或跨进程通信，指两个进程进行数据交换的过程。 IPC不是 Android 中独有的。在Android中最有特色的进程间通信方式就是 Binder 了，通过 Binder 可以轻松实现进程间通信。除了Binder，Android 还支持Socket，通过 Socket 也可以实现任意两个终端的通信。 二、Android 中的多进程模式 IPC机制既然是进程间通信或跨进程通信，那么学习 IPC机制之前我们就先来看看Android 中的多进程模式。2.1、Android 开启多进程模式 正常情况下，在 Android 中使用多进程的只有一种方法，就是给四大组件在 AndroidManifest中 指定 android：process 属性。其实还有另一种非常规的多进程方法，那就是通过 JNI 在 native 层去 fork 一个新的进程。但是这种方法比较特殊，也不是常用的创建多进程方法，所以暂不考虑。 在 AndroidManifest 中指定 android：process 属性有几种不同的方式: 不指定 android：process 属性 默认在默认进程（进程名为当前包名）下运行。 android:process=”:remote” , 组件运行在进程（进程名为 packageName:remote）下。 android:process=”com.lrt.chapter2.remote” ，组件运行在进程、（com.lrt.chapter2.remote）中。 2.2、Android多进程模式的运行机制 Android 为每个应用都分配了一个独立的虚拟机，或者说为每个进程都分配了一个独立的虚拟机。不同的虚拟机在内存上会有不同的地址，这就导致在不同的虚拟机中访问同一个类的对象就会产生多个副本，所以在多进程下无法直接操作静态变量。 线程同步机制完全失效。 SharedPreferences 的可靠性降低。因为 SharedPreferences 不支持两个进程同时去执行操作，否则会导致一定数据的丢失，这是因为 SharedPreferences 底层是通过读/写 xml 文件夹来实现的，并发读写都有可能出现问题。 Application 对多次创建。当一个组件跑在一个新的进程中时，由于系统要创建新的进程并分配独立的虚拟机，因此相当于系统又把这个应用重新启动了一边，即然启动了，那么自然会创建新的 Application。 这个问题可以这么理解： 运行在同进程的组件属于同一个虚拟机同一个 Application，运行在不同进程的组件属于两个不同的虚拟机和 Application。 三、IPC基础概念介绍 IPC 中的基础概念主要包括三方面的内容：Serializable 接口、Parcelable 接口、Binder。 Serializable 和 Parcelable 接口可以完成对象的序列化过程，当我们需要通过 Intent 和 Binder 传输数据时就需要使用 Serializable 和 Parcelable 接口。 3.１、Serializable Serializable 是 java 提供的一个序列化接口，是一个空的接口。为对象提供标准的序列化和反序列化操作。 使用 Serializable 来实现对象的序列化非常简单，只要这个类实现Serializable 接口并声明一个serialVersionUID 即可。private static final long serialVersionUID =878458786668464L; 并且这个UID也不是必须的。 Serializable 的实现过程也很简单：如下: //序列化过程 User user=new User(); ObjectOutputStream out=new ObjectOutputStream( new FileOutputStream(“cache.txt”)); out.writeObject(user); out.close(); //反序列化过程 ObjectInputStream in=new ObjectInputStream( new FileInputStream(“cache.txt”); User user=(User) in.readObject(); in.close(); 3.２、Parcelable Parcelable 也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并可以通过 Intent 和 Binder 传递。 使用 Parcelable 序列化，要先实现 Parcelable 接口，然后要实现 Parcel 类的序列化、反序列化和内容描述几个方法。下图是一个基本用法: 3.3、Binder Binder 是 Android 中的一个类，它实现了 IBinder 接口。从 IPC 角度来说，Binder 是 Android 中的一种跨进程通信方法，Binder 还可以理解为一种虚拟的物理设备，它的驱动设备是 /dev/binder，该通信方式在 Linux中 没有；从 AndroidFramwork 角度来说，Binder 是 ServiceManager 连接各种 Manager （ActivityManager、WindowManager等等）和相应 ManagerService 的桥梁；从 Android 应用层来说，Binder 是客户端和服务端进行通信的媒介，当 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 的对象，通过这个 Binder 对象，客户端就可以获取服务端提供的服务或数据，这里的服务包括普通服务和基于AIDL的服务。 在 Android 开发中，Binder 主要用于在 Service 中，包括 AIDL 和 Messenger，其中普通的 Service 中不涉及进程间通信，而 Messenger 的底层原理是 AIDL。 所以为了分析 Binder，需要新建一个AIDL示例。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 进程间通信","slug":"Android-进程间通信","permalink":"http://yoursite.com/tags/Android-进程间通信/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Activity学习笔记","slug":"Activity学习笔记","date":"2017-09-09T16:00:00.000Z","updated":"2018-01-02T14:48:52.364Z","comments":true,"path":"2017/09/10/Activity学习笔记/","link":"","permalink":"http://yoursite.com/2017/09/10/Activity学习笔记/","excerpt":"","text":"一、Activity 的生命周期典型情况下的生命周期： onCreate() –&gt; activity 正在被创建，执行初始化工作，如 setContentView onRestart() –&gt; activity 正在重新启动 onStart() –&gt; activity 正在启动，已经后台可见，但是用户看不到 onResume() –&gt; activity 前台可见。可以和用户交互 onPause() –&gt; activity 正在停止，此时可以执行一些不耗时的操作，如存储数据，onPause 必须先执行完 新的activity 的onResume 才能执行 onStop() –&gt; activity 即将停止，可以做一些稍微耗时的回收工作，同样不能太耗时 onDestory() –&gt; activity 即将被销毁，回收工作和最终资源的释放 异常情况下的生命周期： 资源相关的系统配置发生改变导致 activity 被杀死 并重新创建（横竖屏切换） 资源内存不足导致低优先级的 activity 被杀死 如果不想在系统配置发生变化时重启 activity 指定 configChanges 属性，比如我们不想在屏幕旋转时重新创建，可以给 configChanges 属性添加 orientation 这个值,如下所示。 二、Activity 的启动模式 standard : 标准模式。每次启动都会创建一个实例，在这种模式下，谁启动了这个activity，那么这个activity就运行在启动它的那个activity 所在的栈上。当我们用非Activity类型的Context 启动activity 时，并没有所谓的栈，所以会报错，解决方式是 为待启动的activity 指定一个FLAG_ACTIVITY_NEW_TASK 标记位,这样启动的时候就会为它创建一个新的任务栈。这时候带启动的activity 实际上是以 singleTask模式启动的。 singleTop ：栈顶复用模式。在这个模式下，如果新activity 已经位于任务栈的栈顶，那么此activity 不会被重新创建，同时它的 onNewIntent方法会被回调，通过此方法，我们可以取出当前请求的信息。需要注意的是，这个activity 的 onCreate、onStart（）不会被重新调用，因为它没有发生改变。 singleTask ：栈内复用模式。这是一种单实例模式，在这种模式下，只要activity 在一个栈中存在，那么多次启动此activity 都不会创建实例，和singleTop，系统也会回调其onNewIntent。SingleTask 模式默认具有clearTop 的效果，会导致启动 activity 上面的所有activity 出栈。 singleInstance : 单实例模式。这是一种加强的 SingleTask 模式，具有此模式的 activity 只能单独地位于一个任务栈中。 三、activity 的 FlagsFLAG_ACTIVITY_NEW_TASK ：和在xml 中指定的singleTask 效果相同。 FLAG_ACTIVITY_SINGLE_TOP ：和在xml 中指定的singleTop效果相同。 FLAG_ACTIVITY_CLEAR_TOP ： 当有此标记的 activity 启动时，在同一个栈中位于它上面的 activity 都要出栈。一般与 FLAG_ACTIVITY_NEW_TASK 配合使用，singleTask 默认具有此效果。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记为的 activity 不会出现在历史 activity 列表中，当某些情况下我们不希望用户通过历史列表回到我们的 activity 的时候这个标记比较有用。 四、IntentFilter的匹配规则 如图所示： 一个 activity 中可以有多个 intent-filter (过滤规则)，一个 intent-filter 可以有多个 action、category、data。 一个 intent 只要匹配任何一组的 intent-filter 即可成功启动对应的 activity。只有同时匹配一个 intent-filter 中的 action、data、category 才算匹配成功。 IntentFilter 中的过滤信息有 action、category、data。 4.1、action 的匹配规则：action 是一个字符串，匹配规则是，一个Intent 中必须存在action 且和过滤规则中的某一个action 相同。 4.2、category 的匹配规则：category 也是一个字符串，匹配规则和 action 不同：一个 Intent 可以设置或不设置 category，如果设置 category 那么每个设置的 category 都必须要跟过滤规则 中的 category 相同才算匹配通过。如果不设置 category，则在 startActivity 或 startActivityforResult 时会默认加上 android.Intent.category.DEFAULT。所以为了 activity 能够被隐式开启，我们要在 Intent-filter 中指定 “ android.intent.category.DEFAULT ” 这个 category。 4.3、data 的匹配规则：4.3.1 在学习data的匹配规则前，我们先来了解下data的结构。 data 由 mimeType 和 URI 组成。mimeType 指的是媒体类型，如 image/jpeg 、video/* 等。而URI 中包含的数据就比较多了下面是URI 的结构 ： &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 例如: content://com.example.project:200/folder/sunfolder/etc http://www.baidu.com:80/search/info SchemeURI 的模式，如 http、file、content。如果没有指定scheme，那么此URI 的其他参数无效，也就是URI无效。 HostURI 的主机名，如 www.baidu.com ，如果没有指定Host，那么此URI也是无效的。 PortURI 的端口号，比如80，仅当URI 中指定了 scheme和host的时候port 才是有效的。 Path、pathPrefix、pathPattern这三个参数都表示路径信息。其中Path 表示完整的路径信息。pathPattern 也表示 完整的路径信息，但是它可以包含 通配符， 表示 0个或多个字符。pathPrefix 表示路径的前缀。 4.3.2 了解完了data的结构，我们再来看data的匹配规则 data 的匹配规则 和 action 类似，它也要求 Intent 中必须含有 data数据，并且data 数据能够完全匹配过滤规则的某一个data 。 如果过滤规则 data中没有指定 URI ，但是却有默认值，默认值是 content 和 file 。也就是说 Intent 中的URI部分的scheme 必须为 content 或者file 才能匹配。 如果要为Intent指定完整的data，那么必须用 setDataAndType（） 方法，因为 setData 和 setType 会彼此清除 对方的值。 最后，当我们用隐式意图开启 activity时，可以做一下判断，看看是否有activity匹配我们的Intent。判断方法有两种：packageManager 的resolveActivity或者 Intent的resolveActivity方法。如果找不到匹配信息会返回null。PackageManager 还有一个 queryIntentActivities 方法可以返回所有匹配成功的activity信息。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"View的事件分发机制","slug":"View的事件分发机制","date":"2017-07-14T16:00:00.000Z","updated":"2018-01-02T14:08:02.031Z","comments":true,"path":"2017/07/15/View的事件分发机制/","link":"","permalink":"http://yoursite.com/2017/07/15/View的事件分发机制/","excerpt":"","text":"一说到事件分发，首先我们要明白这里要分析的对象就是 MotionEvent ，即分发的事件。 所谓 View 的事件分发，其实就是对 MotionEvent 事件的分发过程，即当一个 MotionEvent 产生了以后，系统需要把这个事件传递给一个具体的 View ，而这个传递的过程就是分发的过程。 为了便于理解记忆，我觉得将 View 的事件分发机制 分为三个问题来一步一步的学习效果会更好： 1. 分发的事件 2. 是谁在分发事件 3. 分发的过程 一、分发的事件 （MotionEvent）关于 MotionEvent 。官方是这样介绍的： Object used to report movement (mouse, pen, finger, trackball) events.对象用于报告动作（鼠标、笔、手指、轨迹球）的事件。 简单的来说，我们在手机屏幕上的各种触摸操作都会产生一个个的事件，这些事件被封装成了一个个的 MotionEvent 对象，然后被传递给需要它的 View。 以手指为例,在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种： ACTION_DOWN —— 手指刚接触屏幕 ACTION_MOVE —— 手指在屏幕上移动 ACTION_UP —— 手指从屏幕上松开的一瞬间 正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，考虑如下几种情况： 点击屏幕后离开松开，事件序列为 DOWN –&gt; UP； 点击屏幕滑动一会再松开，事件序列为 DOWN –&gt; MOVE –&gt; ……&gt; MOVE –&gt; UP； 上述两种情况就是典型的事件序列，同时通过 MotionEvent 对象我们可以得到点击事件发生的 x 和 y 坐标。为此系统提供了 getX/getY 和 getRawX/getRawY 两种方法。其中 getX/getY 返回的是相对与当前 View 左上角的 x 和 y 坐标，而 getRawX/getRawY 返回的是相对与手机屏幕左上角的 x 和 y 坐标。 关于 MotionEvent 就先了解到这，下面我们来看第二个问题。 二、是谁在分发事件？","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android View 专题","slug":"Android-View-专题","permalink":"http://yoursite.com/tags/Android-View-专题/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Hello View","slug":"Hello-View","date":"2017-07-08T16:00:00.000Z","updated":"2017-12-31T05:19:51.761Z","comments":true,"path":"2017/07/09/Hello-View/","link":"","permalink":"http://yoursite.com/2017/07/09/Hello-View/","excerpt":"","text":"作为一个 Android 开发者，几乎每一个 Android 项目都离不开 View，虽然说 View 不属于四大组件，但它的重要性丝毫不低于它们，因此今天让我们来重新认识一下 View。 1、什么是 View ？ View（视图）是 Android 中所有控件的基类，不管是简单的 TextView 和 Button 还是 RelativeLayout 和 ListView 他们的共同基类都是 View 。RelativeLayout 继承的 ViewGroup （控件组）也继承自 View ，ViewGroup 内部包含了许多个控件，即一组 View 。所以说 View 是一种界面层的控件的一种抽象，它代表了一个控件或一组控件。 下面一张图可以帮助你理解常用的控件关系 2、View 的位置参数 View 的位置主要由它的四个顶点来决定，分别对应与 View 的四个属性： top、left、right、bottom。需要注意的是，这些坐标都是相对与 View 的父容器来说的，因此它是一种相对坐标。 View 的坐标和父容器的关系见下图： 根据这张图，我们可以很容易的得出 View 的宽高和坐标的关系： width = right - left height = bottom - top 那么如何得到 View 的这四个参数呢？ 也很简单，在 View 的源码中它们对应与 mLeft、mRight、mTop、mBottom这四个成员变量，获取方式如下： left = getLeft(); right = getRight(); top = getTop(); bottom = getBottom(); 从 Android3.0 开始, View 增加了几个额外的参数： x、y、translationX 和 translationＹ，其中 x 和 y 是 View 左上角的坐标，而 translationX 和 translationY 是 View 左上角相对与父容器的偏移量。这几个参数也是相对与父容器的坐标，并且 translationX 和 translationY 的默认值是 0，和 View 的四个基本位置参数一样，View 也为它们提供了 get/set 方法，这几个参数的换算关系如下： x = left + translationX y = top + translationY 需要注意的是，View 在平移的过程中，top 和 left 表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是 x、y、translationX 和 translationY 这四个参数。 3、View 的四个构造函数 public MyView(Context context) java 代码直接 new 一个 Custom View 实例的时候,会调用第一个构造函数 public MyView(Context context,AttributeSet attrs) 在 xml 创建但是没有指定 style 的时候被调用。多了一个 AttributeSet 类型的参数，自定义属性，在通过布局文件 xml 创建一个 view 时，会把 XML 内的参数通过 AttributeSet 带入到 View 内。 public MyView(Context context,AttributeSet attrs,int defStyleAttr) 构造函数中第三个参数是默认的 Style，这里的默认的 Style 是指它在当前 Application 或 Activity 所用的 Theme 中的默认 Style ，且只有在明确调用的时候才会调用 public MyView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) 如果没有使用 defStyleAttr ，则会应用 defStyleRes 到 View 的默认风格。该构造函数是在 API 21 的时候才添加上的 4、View 的生命周期相关方法见下图 生命周期的调用顺序 View 默认为可见的，不是默认值时先调用 onVisibilityChanged()，但是此时该 View 的尺寸、位置等信息都不知道。 可见性改变后才是调用带有两个参数的构造函数，当然，如果该 View 不是在 layout 中定义的话，会调用一个参数的构造函数。 从 XMl 文件中 inflate 完成（onFinishInflate()）。 将 View 加到 window 中（ View 是 gone 的，那么 View 创建生命周期也就结束）。 测量 view 的长宽（onMeasure()）。 定位 View 在父 View 中的位置（onLayout()），若 View 是 invisible，则 View 的创建生命周期结束。 绘制 View 的 content（onDraw()），只有可见的 View 才在 window 中绘制。 View 的销毁流程和可见性没有关系。 所以 View 的生命关键周期为： [改变可见性] --&gt; 构造View() --&gt; onFinishInflate() --&gt; onAttachedToWindow() --&gt; onMeasure() --&gt; onSizeChanged() --&gt;onLayout() --&gt; onDraw() --&gt; onDetackedFromWindow() 参考资料【Android 面试题总结之Android 进阶】【Android 开发艺术探索】【Android View的生命周期】","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android View 专题","slug":"Android-View-专题","permalink":"http://yoursite.com/tags/Android-View-专题/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Java  多线程初探","slug":"Java-多线程初探","date":"2017-06-30T16:00:00.000Z","updated":"2017-12-31T05:15:48.077Z","comments":true,"path":"2017/07/01/Java-多线程初探/","link":"","permalink":"http://yoursite.com/2017/07/01/Java-多线程初探/","excerpt":"","text":"为了加深理解，在学习多线程之前，我们要带着几个问题去学习 什么是进程、线程、多线程？ 为什么要用多线程（多线程有什么用）？ 创建线程的几种方式 线程常见的状态及转换 一、什么是进程、线程、多线程？进程：每一个独立运行的程序就是一个进程，也可以理解为当前正在运行的每一个程序都是一个进程。 线程：一个进程中可以包含一个或多个线程，一个线程就是程序外部的一条执行线索。在java中，程序入口被自动创建为主线程，在主线程中可以创建多个子线程。 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程。 二、为什么要用多线程（多线程有什么用）？ 发挥多核CPU的优势 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。 防止阻塞 从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 三、创建线程的方式创建线程有两种方法： //第一种方法是继承 Thread 类,并重写 Thread 类的 run 方法。 public class MyThread extends Thread { @Override public void run() { // TODO Auto-generated method stub } } //然后，下列代码会创建并启动一个线程： MyThread myThread=new MyThread(); myThread.start(); //另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动。 public class MyThread implements Runnable { @Override public void run() { // TODO Auto-generated method stub } } //然后，下列代码会创建并启动一个线程： MyThread myThread=new MyThread(); new Thread(myThread).start(); 四、线程常见的状态及转换 新建状态（New）：新创建了一个线程对象。 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： ①、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。 ②、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。 ③、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 状态之间的相互转换（见下图） start(): 使线程进入就绪状态。 yield(): 线程让步，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。 wait(): 线程等待，Object类中的方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。 sleep(): 线程睡眠,使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。 join(): 线程加入,等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 notify(): 线程唤醒,Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。 notifyAll(): 唤醒在此对象监视器上等待的所有线程。 interrupt(): 中断线程，如果线程在调用 Object 类的 wait()方法，或者该类的 join()、sleep(long)方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。 参考资料【Java中的多线程你只要看这一篇就够了】 【40个Java多线程问题总结】 【Java多线程学习（吐血超详细总结）】","categories":[],"tags":[{"name":"JavaSE 多线程","slug":"JavaSE-多线程","permalink":"http://yoursite.com/tags/JavaSE-多线程/"}],"keywords":[]},{"title":"hello world","slug":"hello-world","date":"2017-06-21T16:00:00.000Z","updated":"2017-12-30T13:32:48.736Z","comments":true,"path":"2017/06/22/hello-world/","link":"","permalink":"http://yoursite.com/2017/06/22/hello-world/","excerpt":"","text":"折腾了两天，嗯、对是两天。总算把这个东西搞出来了。 第一篇文章的名字 老规矩 hello world 。 先来几张图，因为这可能就是我开始写博客的原因之一 是的，快毕业了。在之前很长的一段时间里，我都以为毕业还早着呢。直到从上一个星期开始，朋友圈各种毕业照刷屏、校园里到处可见的卖书、卖车······ 这本该属于大三学长学姐们的毕业庆典让我们也提前享受了一番 与这些外界的环境相比，真正让我感受到了毕业的还是因为我宿舍的一个兄弟在三天前已经正式迈入了社会，其他的小伙伴也开始忙起来去参加各种面试。 尽管上课我大多都认认真真的在学习，但当毕业真正的到来时，我非常地清楚我还差的远。 两年前，我是个菜鸟，什么都不会。但我不怕，因为我知道我有足够的时间。但两年后呢，如果我还是什么都不会，我不知道我还有什么。 谁能年少不痴狂，独自闯荡 静三631，我们一年后再见 谨此见证我一年后的成长 LiuRenTian","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[],"keywords":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}]}]}