---
title: Java  多线程初探
comments: true
date: 2017-07-01
categories:
tags: JavaSE 多线程
img:
---

### 为了加深理解，在学习多线程之前，我们要带着几个问题去学习

{% blockquote %}

1. 什么是进程、线程、多线程？

2. 为什么要用多线程（多线程有什么用）？

3. 创建线程的几种方式

4. 线程常见的状态及转换

{% endblockquote %}

<br>
## 一、什么是进程、线程、多线程？

进程：每一个独立运行的程序就是一个进程，也可以理解为当前正在运行的每一个程序都是一个进程。

线程：一个进程中可以包含一个或多个线程，一个线程就是程序外部的一条执行线索。在java中，程序入口被自动创建为主线程，在主线程中可以创建多个子线程。

多线程：指的是这个程序（一个进程）运行时产生了不止一个线程。
<br>
## 二、为什么要用多线程（多线程有什么用）？

1. 发挥多核CPU的优势

	随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。

2. 防止阻塞

	从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。

3. 便于建模

	这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。

<br>
## 三、创建线程的方式
{% blockquote %}
创建线程有两种方法：
{% endblockquote %}

```	
//第一种方法是继承 Thread 类,并重写 Thread 类的 run 方法。	
public class MyThread extends Thread {
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		
	}
}

//然后，下列代码会创建并启动一个线程：

MyThread myThread=new MyThread();
myThread.start();



//另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动。

public class MyThread implements Runnable  {
	@Override
	public void run() {
		// TODO Auto-generated method stub
		
	}
}

//然后，下列代码会创建并启动一个线程：

MyThread myThread=new MyThread();
new Thread(myThread).start();
```

## 四、线程常见的状态及转换

1. 新建状态（New）：新创建了一个线程对象。 

2. 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。

3. 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。

4. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

	①、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
	②、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
	③、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

5. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

{% blockquote %}
状态之间的相互转换（见下图）
{% endblockquote %}

![图片加载失败](1.png)



start(): 使线程进入就绪状态。

yield(): 线程让步，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。

wait(): 线程等待，Object类中的方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。

sleep(): 线程睡眠,使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。

join(): 线程加入,等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。

notify(): 线程唤醒,Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。

notifyAll(): 唤醒在此对象监视器上等待的所有线程。

interrupt(): 中断线程，如果线程在调用 Object 类的 wait()方法，或者该类的 join()、sleep(long)方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。

<br>
***
**参考资料**
{% link 【Java中的多线程你只要看这一篇就够了】 http://www.cnblogs.com/wxd0108/p/5479442.html %}

{% link 【40个Java多线程问题总结】 http://www.cnblogs.com/xrq730/p/5060921.html %}
{% link 【Java多线程学习（吐血超详细总结）】 http://blog.csdn.net/gf771115/article/details/51682561 %}


